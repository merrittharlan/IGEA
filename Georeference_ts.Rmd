---
title: "Georeference Total Station"
author: "Merritt Harlan"
date: "8/3/2021"
output: html_document
---

## Correct Total Station Data with GPS data
Adapted from https://gist.github.com/troyhill/2c461cfaaeddf9dcf0fd

```{r input, echo=TRUE}
library(dplyr)
ts_data = read.csv("8_3_Total_Station_Points.csv")
head(ts_data)

etrex_data = read.csv("waypoints_03-AUG-21.csv")
etrex_data = etrex_data %>% select(X, Y, ele, time, name)
head(etrex_data)

#Keep reference points as first three points known:
merged_points = merge(ts_data, etrex_data, by.x = "Etrex.ID", by.y = "name")
colnames(merged_points)[1] = "Code"
knowns = merged_points[1:3,]
```


```{r functions, echo=TRUE}
# this function generates a transform matrix:
# If "unknownData" object doesn't have columns 
# named "Code", "Ground.Northing..m." and "Ground.Easting..m.",
# insert those column names as 'y.unk' and 'x.unk'
genTransform <- function(knownData = knowns, y.col = "Y", x.col = "X", 
                         y.unk = "Northing..m.", x.unk = "Easting..m.", 
                         n = 3) {
  
  # re-format to get the datasets in the same order
  data <- knownData
  data$fill.col <- 1

  #print(noquote(c("Used the following control points: ", paste0(data$Code[1:n], collapse = ", "))))
  # get known coordinates
  k <- as.matrix(data[,c(x.col, y.col, "fill.col"),])
  u <- as.matrix(data[,c(x.unk, y.unk, "fill.col")])
  
  A <- t(solve(u, k)) # this matches matlab output 'A'
}

transMat = genTransform()
print(transMat)

```


```{r functions2, echo=TRUE}
# function to convert between coordinate systems
# be careful that transform matrix and NEunknowns have the same order of northings/eastings
# inputData: dataset to append to
# transformMatrix: matrix used for conversion, generated by genTransform()
# xyPoints: unknown x/y points - it's very important that these appear in the order x, y
# colNames: a vector of strings containing names of columns to append
coordConv <- function (inputData, transformMatrix, xyPoints, colNames) {
  # add columns to receive data
  inputData[, colNames[2]] <- inputData[, colNames[1]] <- NA
  
  xyPoints$fill.col <- 1
  if (!nrow(xyPoints) == 1) {
      for (i in 1:nrow(xyPoints)) {
        outputTemp <- transformMatrix %*% as.numeric(xyPoints[i, ])
        inputData[i, colNames[1]] <- outputTemp[1]
        inputData[i, colNames[2]] <- outputTemp[2]
      }    
  } else { 
    outputTemp <- transformMatrix %*% as.numeric(xyPoints)
    inputData[colNames[1]] <- outputTemp[1]
    inputData[colNames[2]] <- outputTemp[2]
  }
  inputData
}

newPoints <- coordConv(inputData = merged_points, transformMatrix = transMat, 
                       xyPoints = merged_points[,c("Easting..m.",
                                                   "Northing..m.")], 
                       colNames = c("Transformed_Lon", "Transformed_Lat"))

write.csv(newPoints, "Aug_3_2021_TStest.csv")

```


```{r statistics, echo=TRUE}
#find the average distance between points and plot
library(geosphere)

error_diff = vector()
for(i in 1:nrow(newPoints)){
  error_diff[i] = distm(newPoints[i,c("X", "Y")], 
                        newPoints[i,c("Transformed_Lon","Transformed_Lat")], 
                        fun =distHaversine)
}

plot(error_diff, xlab = "Point", ylab = "Error in Distance (m)", main = "Discrepancy in Total Station Location from Triangulation")

```

```{r optimization, echo=TRUE}
#iterate over each unique combination of three points to find the smallest distance

unique_combo = combn(nrow(merged_points),m = 3, simplify = FALSE)
shorter_combo = unique_combo[seq(1, length(unique_combo), 10)]

mean_error = vector()
for(i in 1:length(shorter_combo)){
  knowns = merged_points[c(unlist(shorter_combo[i])),]
  transMat = genTransform()
  temp = merged_points
  newPoints <- coordConv(inputData = temp, transformMatrix = transMat, 
                       xyPoints = temp[,c("Easting..m.",
                                                   "Northing..m.")], 
                       colNames = c("Transformed_Lon", "Transformed_Lat"))
  error_diff = vector()
  for(j in 1:nrow(newPoints)){
    error_diff[j] = distm(newPoints[j,c("X", "Y")], 
                        newPoints[j,c("Transformed_Lon","Transformed_Lat")], 
                        fun =distHaversine)
    
  }
  mean_error[i] = mean(error_diff)
}

summary(mean_error)
```

```{r plot best, echo=TRUE}
#plot best
library(sp)
knowns = merged_points[c(unlist(shorter_combo[which.min(mean_error)])),]
transMat = genTransform()
bestPoints = merged_points
bestPoints <- coordConv(inputData = bestPoints, transformMatrix = transMat, 
                       xyPoints = bestPoints[,c("Easting..m.",
                                                   "Northing..m.")], 
                       colNames = c("Transformed_Lon", "Transformed_Lat"))
error_diff = vector()
for(j in 1:nrow(newPoints)){
  error_diff[j] = distm(newPoints[j,c("X", "Y")], 
                        newPoints[j,c("Transformed_Lon","Transformed_Lat")], 
                        fun =distHaversine)
  }

GNSS_points = bestPoints
coordinates(GNSS_points) = ~X+Y

TS_points = bestPoints
coordinates(TS_points) = ~Transformed_Lon+Transformed_Lat

refPoints = bestPoints[c(unlist(shorter_combo[which.min(mean_error)])),]
coordinates(refPoints) = ~X+Y

plot(GNSS_points, col = "black", pch = 19)
plot(TS_points, col = "blue", pch =24, add = TRUE)
plot(refPoints, col = "red", pch = 19, add = TRUE)
```

